import { fileURLToPath } from "node:url";
import path from "node:path";
import fs from "node:fs";

// const envPath = (file: string): string =>path.resolve(process.cwd(), file);

let envPath = (file: string): string | any => {
  try {
    if (path.isAbsolute(file)) return file;

    // Try project root first (correct behavior)
    const cwdPath = path.resolve(process.cwd(), file);
    if (fs.existsSync(cwdPath)) return cwdPath;

    // Fallback: location relative to module file
    const filePath = path.resolve(
      path.dirname(fileURLToPath(import.meta.url)),
      file
    );
    return filePath;
  } catch (err) {
    console.log(`${err}`);
    return `${err}`;
  }
};

let files: string[] = [];

export function see(): void {
  console.log(`Loaded env files: ${files}`);
}

let env: Record<string, string> = {};

export function pathLoad(file: string): typeof env | undefined | string {
  try {
    if (!fs.existsSync(file)) {
      env = process.env as Record<string, any>;
      console.warn(`No .env file found at ${file}`);
      return env;
    }

    const lines = fs
      .readFileSync(file, "utf-8")
      .split(/\r?\n/) // split by lines
      .filter(Boolean) // remove empty lines
      .filter((line: string) => !line.trim().startsWith("#")) // skip comments
      .map((line: string) => line.split("="));

    for (const [key, ...rest] of lines) {
      if (!key) {
        return undefined;
      }
      const cleanKey = key.trim();
      const value = rest.join("=").trim();
      if (cleanKey) env[cleanKey] = value;
    }

    console.log(`File on ${file} loaded successfully.`);
    files.push(file);
    setKeys(Object.keys(env), { override: true });

    return env;
  } catch (err) {
    console.error(`${err}`);
    return `${err}`;
  }
}

export function autoLoad(options: { override?: boolean } = {}): typeof env {
  const { override = true } = options;

  const NODE_ENV = process.env.NODE_ENV || "development";

  const candidates = [
    `.env.${NODE_ENV}.local`,
    `.env.local`,
    `.env.${NODE_ENV}`,
    `.env`,
  ];

  for (const file of candidates) {
    const filePath = envPath(file);

    if (fs.existsSync(filePath)) {
      console.log(`ðŸ”¹ Loading: ${filePath}`);
      load(filePath); // your existing function
      setKeys(Object.keys(env), { override });
    }
  }

  return env;
}

export function load(file: string = ".env"): typeof env | undefined | string {
  try {
    let pathFile = envPath(file);
    if (!fs.existsSync(pathFile)) {
      console.warn(`No ${file} file found at ${pathFile}`);
      env = process.env as Record<string, any>;
      return env;
    }
    const lines = fs
      .readFileSync(pathFile, "utf-8")
      .split(/\r?\n/) // split by lines
      .filter(Boolean) // remove empty lines
      .filter((line: string) => !line.trim().startsWith("#")) // skip comments
      .map((line: string) => line.split("="));

    for (const [key, ...rest] of lines) {
      if (!key) {
        return undefined;
      }
      const cleanKey = key.trim();
      const value = rest.join("=").trim();
      if (cleanKey) env[cleanKey] = value;
    }

    console.log(`File loaded ${pathFile}.`);
    files.push(pathFile);
    setKeys(Object.keys(env), { override: true });

    return env;
  } catch (err) {
    console.error(`${err}`);
    return `${err}`;
  }
}

export function setKey<T extends string>(key: T): T | undefined {
  try {
    if (key.includes(" ")) console.warn(`âš  Invalid key name: "${key}"`);

    if (!(key in env)) {
      console.warn(`Missing env key: ${key}`);
      return undefined;
    }

    process.env[key] = env[key]; //injection of keys in process.env
    return key;
  } catch (err) {
    console.error(`Error : ${err} `);
  }
}

export function setKeys<T extends string>(
  keys: T[],
  options: { override?: boolean } = {}
): string {
  const { override = true } = options;
  try {
    for (const key of keys) {
      if (key.includes(" ")) {
        console.warn(`Invalid key name: "${key}"`);
        continue;
      }

      if (!(key in env)) {
        console.warn(`Missing env key: ${key}`);
        continue;
      }

      if (override || !(key in process.env)) {
        process.env[key] = env[key];
      }
    }

    return `Injected keys: ${keys.join(", ")}`;
  } catch (err) {
    return `Error: ${err}`;
  }
}

export function keys(): any[] | string {
  try {
    return Object.keys(env).length
      ? `Keys injected : ${Object.keys(process.env).filter(
          (key) => key in env
        )}`
      : `May be env isn't loaded.`;
  } catch (err) {
    console.log(`${err}`);
    return `${err}`;
  }
}

export function getKey<T extends string>(key: T): string | undefined {
  if (process.env[key]) {
    return process.env[key];
  }
  if (env[key]) {
    return env[key];
  }
  return undefined;
}

let index = { load, setKey, setKeys, pathLoad, keys, getKey, see, autoLoad };

export default index;

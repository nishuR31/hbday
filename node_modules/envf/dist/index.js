import { fileURLToPath } from "node:url";
import path from "node:path";
import fs from "node:fs";
// const envPath = (file: string): string =>path.resolve(process.cwd(), file);
let envPath = (file) => {
    try {
        if (path.isAbsolute(file))
            return file;
        // Try project root first (correct behavior)
        const cwdPath = path.resolve(process.cwd(), file);
        if (fs.existsSync(cwdPath))
            return cwdPath;
        // Fallback: location relative to module file
        const filePath = path.resolve(path.dirname(fileURLToPath(import.meta.url)), file);
        return filePath;
    }
    catch (err) {
        console.log(`${err}`);
        return `${err}`;
    }
};
let files = [];
export function see() {
    console.log(`Loaded env files: ${files}`);
}
let env = {};
export function pathLoad(file) {
    try {
        if (!fs.existsSync(file)) {
            env = process.env;
            console.warn(`No .env file found at ${file}`);
            return env;
        }
        const lines = fs
            .readFileSync(file, "utf-8")
            .split(/\r?\n/) // split by lines
            .filter(Boolean) // remove empty lines
            .filter((line) => !line.trim().startsWith("#")) // skip comments
            .map((line) => line.split("="));
        for (const [key, ...rest] of lines) {
            if (!key) {
                return undefined;
            }
            const cleanKey = key.trim();
            const value = rest.join("=").trim();
            if (cleanKey)
                env[cleanKey] = value;
        }
        console.log(`File on ${file} loaded successfully.`);
        files.push(file);
        setKeys(Object.keys(env), { override: true });
        return env;
    }
    catch (err) {
        console.error(`${err}`);
        return `${err}`;
    }
}
export function autoLoad(options = {}) {
    const { override = true } = options;
    const NODE_ENV = process.env.NODE_ENV || "development";
    const candidates = [
        `.env.${NODE_ENV}.local`,
        `.env.local`,
        `.env.${NODE_ENV}`,
        `.env`,
    ];
    for (const file of candidates) {
        const filePath = envPath(file);
        if (fs.existsSync(filePath)) {
            console.log(`ðŸ”¹ Loading: ${filePath}`);
            load(filePath); // your existing function
            setKeys(Object.keys(env), { override });
        }
    }
    return env;
}
export function load(file = ".env") {
    try {
        let pathFile = envPath(file);
        if (!fs.existsSync(pathFile)) {
            console.warn(`No ${file} file found at ${pathFile}`);
            env = process.env;
            return env;
        }
        const lines = fs
            .readFileSync(pathFile, "utf-8")
            .split(/\r?\n/) // split by lines
            .filter(Boolean) // remove empty lines
            .filter((line) => !line.trim().startsWith("#")) // skip comments
            .map((line) => line.split("="));
        for (const [key, ...rest] of lines) {
            if (!key) {
                return undefined;
            }
            const cleanKey = key.trim();
            const value = rest.join("=").trim();
            if (cleanKey)
                env[cleanKey] = value;
        }
        console.log(`File loaded ${pathFile}.`);
        files.push(pathFile);
        setKeys(Object.keys(env), { override: true });
        return env;
    }
    catch (err) {
        console.error(`${err}`);
        return `${err}`;
    }
}
export function setKey(key) {
    try {
        if (key.includes(" "))
            console.warn(`âš  Invalid key name: "${key}"`);
        if (!(key in env)) {
            console.warn(`Missing env key: ${key}`);
            return undefined;
        }
        process.env[key] = env[key]; //injection of keys in process.env
        return key;
    }
    catch (err) {
        console.error(`Error : ${err} `);
    }
}
export function setKeys(keys, options = {}) {
    const { override = true } = options;
    try {
        for (const key of keys) {
            if (key.includes(" ")) {
                console.warn(`Invalid key name: "${key}"`);
                continue;
            }
            if (!(key in env)) {
                console.warn(`Missing env key: ${key}`);
                continue;
            }
            if (override || !(key in process.env)) {
                process.env[key] = env[key];
            }
        }
        return `Injected keys: ${keys.join(", ")}`;
    }
    catch (err) {
        return `Error: ${err}`;
    }
}
export function keys() {
    try {
        return Object.keys(env).length
            ? `Keys injected : ${Object.keys(process.env).filter((key) => key in env)}`
            : `May be env isn't loaded.`;
    }
    catch (err) {
        console.log(`${err}`);
        return `${err}`;
    }
}
export function getKey(key) {
    if (process.env[key]) {
        return process.env[key];
    }
    if (env[key]) {
        return env[key];
    }
    return undefined;
}
let index = { load, setKey, setKeys, pathLoad, keys, getKey, see, autoLoad };
export default index;
//# sourceMappingURL=index.js.map